<!DOCTYPE html>
<html lang="en">

<head>
	<meta charset="UTF-8" />
	<meta name="viewport" content="width=device-width, initial-scale=1.0" />
	<title>FLO Scout</title>
	<link rel="stylesheet" href="css/main.css" />
</head>

<body data-theme="light">
	<h5 id="textCopied" class="hide">
		Copied
	</h5>
	<div id="loader_page" class="hide-completely">
		<svg id="loader" class="icon" viewBox="0 0 64 64">
			<title>Loading</title>
			<circle cx="32" cy="32" r="32" />
		</svg>
		<h4>Loading</h4>
	</div>
	<div class="page hide" id="search_page">
		<header class="flex">
			<h1 class="other-font">Search</h1>
			<svg id="close_search_btn" class="icon" viewBox="0 0 64 64">
				<title>close</title>
				<line x1="64" y1="0" x2="0" y2="64" />
				<line x1="64" y1="64" x2="0" y2="0" />
			</svg>
		</header>
		<label id="secondary_search" class="input">
			<svg class="icon" viewBox="0 0 64 64">
				<title>search icon</title>
				<circle cx="25.34" cy="25.34" r="24.84" />
				<line x1="63.65" y1="63.65" x2="42.91" y2="42.91" />
			</svg>
			<input id='main_search_field' autocomplete="off" type="search"
				placeholder="block, transactions, address, token or contract">
			<ul id="suggestions"></ul>
		</label>
	</div>
	<header id="page_header" class="flex margin">
		<svg class="icon" onclick="history.back()" viewBox="0 0 64 64">
			<title>back_arrow</title>
			<polyline points="25.97 6.24 0.5 32.06 25.92 57.83" />
			<line x1="20" y1="32" x2="64" y2="32" />
		</svg>
		<h3 id="page_title"></h3>
		<label class="toggle" style="margin-left: auto" title="Change theme">
			<input type="checkbox" name="theme toggle" id="theme_toggle">
			<div class="switch">
				<svg class="circle" viewBox="0 0 64 64">
					<title>dark theme</title>
					<path
						d="M48.25,45.45A27.26,27.26,0,0,1,20.82,18.37,26.75,26.75,0,0,1,27.47.71a31.71,31.71,0,0,0-27,31.2,31.8,31.8,0,0,0,32,31.59A32,32,0,0,0,63.12,41.12,27.59,27.59,0,0,1,48.25,45.45Z"
						transform="translate(0 0)" />
				</svg>
				<svg class="circle" viewBox="0 0 64 64">
					<title>light theme</title>
					<circle cx="32" cy="32" r="13.9" />
					<line x1="32" y1="6.86" x2="32" />
					<line x1="32" y1="64" x2="32" y2="57.14" />
					<line x1="57.14" y1="32" x2="64" y2="32" />
					<line y1="32" x2="6.86" y2="32" />
					<line x1="49.78" y1="14.22" x2="54.63" y2="9.37" />
					<line x1="9.37" y1="54.63" x2="14.22" y2="49.78" />
					<line x1="49.78" y1="49.78" x2="54.63" y2="54.63" />
					<line x1="9.37" y1="9.37" x2="14.22" y2="14.22" />
				</svg>
			</div>
		</label>
		<svg id="secondary_search_btn" class="icon hover" viewBox="0 0 64 64">
			<title>
				search for block, transactions, address, token or contract
			</title>
			<circle cx="25.34" cy="25.34" r="24.84" />
			<line x1="63.65" y1="63.65" x2="42.91" y2="42.91" />
		</svg>
	</header>
	<main id="page_container">
	</main>

	<!-- Set urls for token and flo Apis -->
	<script>
		window.tokenapiUrl = 'https://ranchimallflo.duckdns.org'
		window.floapiUrl = 'https://flosight.duckdns.org'
	</script>

	<script>
		let frag = document.createDocumentFragment();

		function creation(str) {
			return document.createRange().createContextualFragment(str)
		};
		const create = {
			homepage(obj) {
				let {
					topToken,
					totalTransactions,
					walletAddresses,
					topContract,
				} = obj,
					page = document.createElement("div");
				page.classList.add("page");
				page.id = "homepage";
				page.innerHTML = `
              <section id="first_section">
              <header class="header flex">
                  <div id="logo">
                      <svg id="main_logo" viewBox="0 0 27.25 32">
                          <title>RanchiMall</title>
                          <path d="M27.14,30.86c-.74-2.48-3-4.36-8.25-6.94a20,20,0,0,1-4.2-2.49,6,6,0,0,1-1.25-1.67,4,4,0,0,1,0-2.26c.37-1.08.79-1.57,3.89-4.55a11.66,11.66,0,0,0,3.34-4.67,6.54,6.54,0,0,0,.05-2.82C20,3.6,18.58,2,16.16.49c-.89-.56-1.29-.64-1.3-.24a3,3,0,0,1-.3.72l-.3.55L13.42.94C13,.62,12.4.26,12.19.15c-.4-.2-.73-.18-.72.05a9.39,9.39,0,0,1-.61,1.33s-.14,0-.27-.13C8.76.09,8-.27,8,.23A11.73,11.73,0,0,1,6.76,2.6C4.81,5.87,2.83,7.49.77,7.49c-.89,0-.88,0-.61,1,.22.85.33.92,1.09.69A5.29,5.29,0,0,0,3,8.33c.23-.17.45-.29.49-.26a2,2,0,0,1,.22.63A1.31,1.31,0,0,0,4,9.34a5.62,5.62,0,0,0,2.27-.87L7,8l.13.55c.19.74.32.82,1,.65a7.06,7.06,0,0,0,3.46-2.47l.6-.71-.06.64c-.17,1.63-1.3,3.42-3.39,5.42L6.73,14c-3.21,3.06-3,5.59.6,8a46.77,46.77,0,0,0,4.6,2.41c.28.13,1,.52,1.59.87,3.31,2,4.95,3.92,4.95,5.93a2.49,2.49,0,0,0,.07.77h0c.09.09,0,.1.9-.14a2.61,2.61,0,0,0,.83-.32,3.69,3.69,0,0,0-.55-1.83A11.14,11.14,0,0,0,17,26.81a35.7,35.7,0,0,0-5.1-2.91C9.37,22.64,8.38,22,7.52,21.17a3.53,3.53,0,0,1-1.18-2.48c0-1.38.71-2.58,2.5-4.23,2.84-2.6,3.92-3.91,4.67-5.65a3.64,3.64,0,0,0,.42-2A3.37,3.37,0,0,0,13.61,5l-.32-.74.29-.48c.17-.27.37-.63.46-.8l.15-.3.44.64a5.92,5.92,0,0,1,1,2.81,5.86,5.86,0,0,1-.42,1.94c0,.12-.12.3-.15.4a9.49,9.49,0,0,1-.67,1.1,28,28,0,0,1-4,4.29C8.62,15.49,8.05,16.44,8,17.78a3.28,3.28,0,0,0,1.11,2.76c.95,1,2.07,1.74,5.25,3.32,3.64,1.82,5.22,2.9,6.41,4.38A4.78,4.78,0,0,1,21.94,31a3.21,3.21,0,0,0,.14.92,1.06,1.06,0,0,0,.43-.05l.83-.22.46-.12-.06-.46c-.21-1.53-1.62-3.25-3.94-4.8a37.57,37.57,0,0,0-5.22-2.82A13.36,13.36,0,0,1,11,21.19a3.36,3.36,0,0,1-.8-4.19c.41-.85.83-1.31,3.77-4.15,2.39-2.31,3.43-4.13,3.43-6a5.85,5.85,0,0,0-2.08-4.29c-.23-.21-.44-.43-.65-.65A2.5,2.5,0,0,1,15.27.69a10.6,10.6,0,0,1,2.91,2.78A4.16,4.16,0,0,1,19,6.16a4.91,4.91,0,0,1-.87,3c-.71,1.22-1.26,1.82-4.27,4.67a9.47,9.47,0,0,0-2.07,2.6,2.76,2.76,0,0,0-.33,1.54,2.76,2.76,0,0,0,.29,1.47c.57,1.21,2.23,2.55,4.65,3.73a32.41,32.41,0,0,1,5.82,3.24c2.16,1.6,3.2,3.16,3.2,4.8a1.94,1.94,0,0,0,.09.76,4.54,4.54,0,0,0,1.66-.4C27.29,31.42,27.29,31.37,27.14,30.86ZM6.1,7h0a3.77,3.77,0,0,1-1.46.45L4,7.51l.68-.83a25.09,25.09,0,0,0,3-4.82A12,12,0,0,1,8.28.76c.11-.12.77.32,1.53,1l.63.58-.57.84A10.34,10.34,0,0,1,6.1,7Zm5.71-1.78A9.77,9.77,0,0,1,9.24,7.18h0a5.25,5.25,0,0,1-1.17.28l-.58,0,.65-.78a21.29,21.29,0,0,0,2.1-3.12c.22-.41.42-.76.44-.79s.5.43.9,1.24L12,5ZM13.41,3a2.84,2.84,0,0,1-.45.64,11,11,0,0,1-.9-.91l-.84-.9.19-.45c.34-.79.39-.8,1-.31A9.4,9.4,0,0,1,13.8,2.33q-.18.34-.39.69Z"/>
                      </svg>
                      <h4>RanchiMall</h4>
                  </div>
              </header>
              <div id="main_search">
                  <h2 class="other-font">FLO SCOUT</h2>
                  <h4>Search for<br>block, transaction, address,<br>token and contract</h4>
                  <label id="primary_search" class="input">
                      <svg class="icon" viewBox="0 0 64 64">
                          <title>search icon</title>
                          <circle cx="25.34" cy="25.34" r="24.84"/>
                          <line x1="63.65" y1="63.65" x2="42.91" y2="42.91"/>
                      </svg>
                      <input id="homepage_search" autocomplete="off" type="search" placeholder="Search" disabled>
                  </label>
              </div>
          <div id="highlights">
              <div class="highlight-item">
                  <h4 class="label">top token</h4>
                  <h2 class="token">${topToken}</h2>
              </div>
              <div class="highlight-item">
                  <h4 class="label">Latest transactions</h4>
                  <h2>${totalTransactions}</h2>
              </div>
              <div class="highlight-item">
                  <h4 class="label">Wallet addresses</h4>
                  <h2>${walletAddresses}</h2>
              </div>
              <div class="highlight-item">
                  <h4 class="label">top contract</h4>
                  <h2 class="contract capitalise" data-contract-address="${topContract.address}">${replaceDash(topContract.name)}</h2>
              </div>
          </div>
      </section>
      <section id="latest_transaction_section">
          <header class="grid grid-2 header">
              <h3 class="heading">Latest transactions</h3>
              <button id='all_trans_btn' class="margin-left-auto">view all</button>
          </header>
          <div id="top_transaction_container" class="transaction-container">
          </div>
      </section>
      <section id="latest_blocks_section">
          <header class="grid grid-2 header">
              <h3 class="heading">Latest blocks</h3>
              <button id='all_blocks_btn' class="margin-left-auto">view all</button>
          </header>
          <div id="top_blocks_container">
          </div>
      </section>
              `;
				return page;
			},
			blockPage(obj) {
				let {
					blockHeight,
					size,
					transactions,
					reward,
					hash,
					difficulty,
					nonce,
				} = obj,
					page = document.createElement("div"),
					wordForm = "transaction";
				if (transactions > 1) wordForm = "transactions";
				page.classList.add("page");
				page.id = "block_page";

				page.innerHTML = `
              <h5 class="label">Block Height</h5>
              <h2 class="block-height">${blockHeight}</h2>
              <div class="card">
                  <h4>1 ${wordForm}</h4>
                  <h5 class="label">${size}</h5>
                  <h5 class="label">Reward</h5>
                  <h4>${reward}</h4>
                  <h5 class="label">Transaction ID</h5>
                  <h4 class="breakable">${hash}</h4>
                  <h5 class="label">Difficulty</h5>
                  <h4>${difficulty}</h4>
                  <h5 class="label">Nonce</h5>
                  <h4>${nonce}</h4>
              </div>
              <h3 class="heading">Transactions</h3>
              <div id="block_transaction_container" class="top-bottom-padding">
              </div>`;
				return page;
			},
			addressPage(obj) {
				let {
					balance,
					address
				} = obj,
					page = document.createElement("div");
				page.classList.add("page");
				page.id = "address_page";
				page.innerHTML = `
              <div class="balance-card">
                <h5 class="label">Balance</h5>
                <h3>${balance} FLO</h3>
                  <svg class="flo-logo" viewBox="0 0 48 48">
                      <path d="M34.2,32.4c0,0,3.75-0.18,7.41-3.86c2.96-2.98,3.65-6.66,3.99-8.52c-11.04-0.63-12.36,0.99-13.71,1.68
                      c-1.19,0.61-5.33,4.55-5.33,4.55s3.06-3.13,3.2-9.94c0.09-4.54-1.02-7.39-2.72-10.64C25.29,2.33,22.79,0,22.79,0l0.01,4.97
                      c0,0,4.35,2.84,4.35,11.84c0,6.52-4.35,11.02-4.35,11.02s-4.35-4.5-4.35-11.02c0-9.01,4.35-11.84,4.35-11.84L22.79,0
                      c0,0-2.48,2.33-4.23,5.67c-1.7,3.25-2.81,6.1-2.72,10.64c0.13,6.81,3.2,9.94,3.2,9.94s-4.14-3.95-5.33-4.55
                      c-1.35-0.69-2.67-2.31-13.71-1.68c0.34,1.86,1.03,5.54,3.99,8.52c3.66,3.68,7.41,3.86,7.41,3.86s-5.05-2.03-7.15-9.45
                      c0,0,5.76-0.7,9.63,1.87c2.52,1.67,4.86,4.26,6.79,6.01c0,0-2.58-0.04-6.81,1.88c-2.54,1.15-3.92,2.84-4.44,4.38
                      c-0.36,1.06-0.2,2.27-0.2,2.27s3.31,0.31,5.94,0c1.99-0.23,3.42-2.16,3.42-2.16s-2,0.78-3.95,0.78c-2.06,0-2.67-0.66-2.67-0.66
                      c0.98-3.64,8.68-5.19,8.68-5.19s-1.34,2.6-1.42,6.5c-0.1,4.79,3.57,8.52,3.57,8.45c0,0.07,3.67-3.66,3.57-8.45
                      c-0.08-3.9-1.42-6.5-1.42-6.5s7.71,1.55,8.68,5.19c0,0-0.61,0.66-2.67,0.66c-1.95,0-3.95-0.78-3.95-0.78s1.43,1.93,3.42,2.16
                      c2.63,0.31,5.94,0,5.94,0s0.16-1.21-0.2-2.27c-0.52-1.54-1.9-3.23-4.44-4.38c-4.23-1.92-6.81-1.88-6.81-1.88
                      c1.93-1.76,4.27-4.34,6.79-6.01c3.87-2.57,9.63-1.87,9.63-1.87C39.26,30.38,34.2,32.4,34.2,32.4z M22.8,43.06
                      c-0.95-1.37-1.47-2.13-1.47-4.26c0-2.4,1.12-4.61,1.47-5.14c0.35,0.52,1.47,2.74,1.47,5.14C24.27,40.92,23.75,41.69,22.8,43.06z"/>
                  </svg>
                  <p class="breakable">${address}</p>
              </div>
              <div class="tabs">
                    <h4 class="tab active" data-rank="1" data-target="address_transaction_container">Transactions</h4>
                    <h4 class="tab" data-rank="2" data-target="token_balance_container">Token Balance</h4>
                    <div class="line"></div>
                </div>
                <ul id="address_transaction_container" data-tab-group="address" class="transaction-container"></ul>
                <ul id="token_balance_container" data-tab-group="address" class="hide-completely"></ul>`;
				return page;
			},
			tokenBalanceCard(token, balance) {
				let card = document.createElement('li')
				card.classList.add('card')
				card.innerHTML = `
                  <h5 class="label uppercase token">${token}</h5>
                  <h4>${balance}</h4>
                `
				return card
			},
			transactionPage(obj) {
				let { type, name, blockHeight, amount, sender, receiver, floData, hash, confirmations } = obj,
					page = document.createElement("div");
				page.classList.add("page");
				page.id = "transaction_page";
				page.innerHTML = `
              <div class='head'>
                  	<h5 class="label">${type}</h5>
                  	<h2 class="token uppercase">${name}</h2>
					<h5 class="label">Transaction ID</h5>
					<div class="copy-row">
                    	<h4 class="breakable copy">${hash}</h4>
                        <svg class="icon" onclick="copyToClipboard(this.parentNode)" viewBox="0 0 54 64">
                            <title>Copy</title>
                            <path d="M53,0H22.14a6,6,0,0,0-6,6v5H11a6,6,0,0,0-6,6V58a6,6,0,0,0,6,6H41.86a6,6,0,0,0,6-6V53H53a6,6,0,0,0,6-6V6A6,6,0,0,0,53,0ZM43.89,58a2,2,0,0,1-2,2H11a2,2,0,0,1-2-2V17.06a2,2,0,0,1,2-2H41.86a2,2,0,0,1,2,2ZM55,46.94a2,2,0,0,1-2,2H47.89V17.06a6,6,0,0,0-6-6H20.11V6a2,2,0,0,1,2-2H53a2,2,0,0,1,2,2Z" transform="translate(-5)"/>
                        </svg>
                    </div>
              </div>
              <div class="card">
					<h5 class="label">Block</h5>
					<h4 class="block-height">${blockHeight}</h4>
					<h5 class="label">Amount</h5>
					<h4>${amount}</h4>
					<h5 class="label">Sender</h5>
					<h4 class="address">${sender}</h4>
					<h5 class="label">Reciever</h5>
					<h4 class="address">${receiver}</h4>
              </div>
              <div class="card">
					<h5 class="label">FLO Data</h5>
					<p>${floData}</p>
					<h5 class="label">Block Confirmations</h5>
					<h4>${confirmations}</h4>
              </div>
              `;
				return page;
			},
			searchPage() {
				let page = document.createElement("div");
				page.classList.add("page");
				page.id = "search_page";
				page.innerHTML = `
				
				`
				return page;
			},
			alltransactionsPage() {
				let page = document.createElement("div");
				page.classList.add("page", "transaction-container");
				page.id = "all_transactions_page";
				return page;
			},
			allBlocksPage() {
				let page = document.createElement("div");
				page.classList.add("page");
				page.id = "all_blocks_page";
				return page;
			},
			addrBalanceCard(address, balance, token) {
				let card = document.createElement('li')
				card.classList.add('balance')
				card.innerHTML = `
                        <h5 class="address breakable label">${address}</h5>
                        <h4 class="uppercase">${balance} ${token}</h4>`
				return card
			},
			tokenPage(obj) {
				let {
					token,
					supply,
					incAddress
				} = obj;
				let page = document.createElement("div");
				page.classList.add("page");
				page.id = "token_page";
				page.innerHTML = `
                <div class="card">
                  <h2 class="uppercase">${token}</h2>
                  <h5 class="label">Supply</h5>
                  <h4>${supply}</h4>
                  <h5 class="label">Address</h5>
                  <h4 class="breakable">${incAddress}</h4>
                </div>
                <div class="tabs">
                    <h4 class="tab active" data-rank="1" data-target="token_balance_container">Top Balances</h4>
                    <h4 class="tab" data-rank="2" data-target="token_transaction_container">Top Transactions</h4>
                    <div class="line"></div>
                </div>
                <ul id="token_balance_container" data-tab-group="token" class="card"></ul>
                <ul id="token_transaction_container" data-tab-group="token" class="transaction-container hide-completely"></ul>
              `;
				return page;
			},
			contractPage(obj) {
				let { status, contract, contractType, contractAddress, expiration, token, participationFees, userChoices, payeeAddress, minAmount, maxAmount } = obj,
					page = document.createElement("div");
				page.classList.add("page");
				page.id = "contract_page";
				let userChoiceSection = document.createElement('ul'),
					infoCard = document.createElement('div');
				infoCard.classList.add('card')
				userChoiceSection.classList.add('card')
				userChoiceSection.type = 'circle'
				if (userChoices) {
					for (choice in userChoices) {
						userChoiceSection.innerHTML += `<li>${userChoices[choice]}</li>`
					}
				}
				page.append(creation(`
                    <div class="status closed">${status}</div>
                    <h3 class="uppercase">${replaceDash(contract)}</h3>`))
				infoCard.innerHTML = `
                        <h5 class="label">Contract Type</h5>
                        <h4>${replaceDash(contractType)}</h4>
                        <h5 class="label">Contract Address</h5>
                        <h4 class="address">${contractAddress}</h4>`
				if (expiration)
					infoCard.append(creation(`
                  <h5 class="label">Expiration</h5>
                  <h4>${expiration}</h4>`))
				if (payeeAddress)
					infoCard.append(creation(`
                  <h5 class="label">Payee Address</h5>
                  <h4>${payeeAddress}</h4>`))
				if (minAmount)
					infoCard.append(creation(`
                  <h5 class="label">Min. Subscription Amount</h5>
                  <h4>${minAmount}</h4>`))
				if (maxAmount)
					infoCard.append(creation(`
                  <h5 class="label">Max. Subscription Amount</h5>
                  <h4>${maxAmount}</h4>`))
				if (participationFees)
					infoCard.append(creation(`
                  <h5 class="label">Participation Amount</h5>
                  <h4>${participationFees}</h4>`))
				infoCard.append(creation(`<h5 class="label">Token Used</h5>
                        <h4 class="uppercase">${token}</h4>`))
				page.append(infoCard)
				if (userChoices) {
					page.append(creation(`
                <h3 class="heading">User Choices</h3>`))
					page.append(userChoiceSection)
				}
				page.append(creation(`<div class="tabs">
                  <h4 class="tab active" data-rank="1" data-target="contract_transaction_container">Transactions</h4>
                  <h4 class="tab" data-rank="2" data-target="participant_container">Participants</h4>
                  <h4 class="tab" data-rank="3" data-target="winners_container">Winners</h4>
                  <div class="line"></div>
              </div>
              <ul id="participant_container" data-tab-group="contract" class="card"></ul>
              <ul id="winners_container" data-tab-group="contract" class="card hide-completely"></ul>
              <div id="contract_transaction_container" data-tab-group="contract" class="transaction-container"></div>`));
				return page;
			},
			contractChoiceCard(address, token, choice, amount, winningAmount) {
				let card = document.createElement('li'),
					action;
				card.classList.add('contract-choice')
				if (winningAmount) {
					action = 'Won'
					amount = winningAmount
				}
				else
					action = 'Invested'
				card.innerHTML = `   
                      <h4 class="address breakable">${address}</h4>
                      <h4>${choice}</h4>
                      <h4 class="uppercase">${amount} ${token} ${action}</h4>`
				return card;
			},
			contractTransferCard(obj) {
				let { hash, blockHeight, token, sender, receiver, amount, contractName, userChoice } = obj,
					card = document.createElement("div"),
					contractInfo = document.createElement('div');
				contractInfo.classList.add('contract-info')
				card.classList.add("transaction", "token-transfer");
				card.id = hash;
				card.innerHTML = `
                            <svg class="icon" viewBox="0 0 64 64">
                              <title>contract</title>
                              <path d="M4.75,49.27A8,8,0,0,0,4.2,61.14a7.82,7.82,0,0,0,4.34,2.24,7.42,7.42,0,0,0,1.34.12H47.41a8.06,8.06,0,0,0,8.05-8V7.87"/>
                              <path d="M8.54,56.13V8.54a8.06,8.06,0,0,1,8.05-8H54.12a7.42,7.42,0,0,1,1.34.12A7.82,7.82,0,0,1,59.8,2.86a8,8,0,0,1-.55,11.87"/>
                              <line x1="17.93" y1="22.62" x2="46.07" y2="22.62"/>
                              <line x1="17.93" y1="32" x2="46.07" y2="32"/>
                              <line x1="17.93" y1="41.38" x2="38.03" y2="41.38"/>
                            </svg>
                              <div class="contract-type">
                                  <h5 class="label">Smart Contract Transfer</h5>
                                  <h4 class="token uppercase">${token}</h4>
                              </div>`
				contractInfo.innerHTML = `    
									
									<h5 class="label">Sender</h5>
									<h4 class="address">${sender}</h4>
									<h5 class="label">receiver</h5>
									<h4 class="address">${receiver}</h4>
									<h5 class="label">amount</h5>
									<h4 class="uppercase">${amount} ${token}</h4>
									<h5 class="label">Contract name</h5>
                  <h4>${contractName}</h4>
                  <h5 class="label">Transaction ID</h5>
									<div class="copy-row">
										<h6 class="breakable copy hash">${hash}</h6>
										<svg class="icon" onclick="copyToClipboard(this.parentNode)" viewBox="0 0 54 64">
											<title>Copy</title>
											<path d="M53,0H22.14a6,6,0,0,0-6,6v5H11a6,6,0,0,0-6,6V58a6,6,0,0,0,6,6H41.86a6,6,0,0,0,6-6V53H53a6,6,0,0,0,6-6V6A6,6,0,0,0,53,0ZM43.89,58a2,2,0,0,1-2,2H11a2,2,0,0,1-2-2V17.06a2,2,0,0,1,2-2H41.86a2,2,0,0,1,2,2ZM55,46.94a2,2,0,0,1-2,2H47.89V17.06a6,6,0,0,0-6-6H20.11V6a2,2,0,0,1,2-2H53a2,2,0,0,1,2,2Z" transform="translate(-5)"/>
										</svg>
									</div>`;
				card.append(contractInfo)
				return card;
			},
			tokenTransferCard(obj) {
				let {
					hash,
					blockHeight,
					token,
					sender,
					receiver,
					amount
				} = obj,
					card = document.createElement("div");
				card.classList.add("transaction", "token-transfer");
				card.id = hash;
				card.innerHTML = `    <svg class="icon" viewBox="0 0 64 64">
                                  <title>transfer</title>
                                  <polyline points="17.04 35.97 14.57 33.5 40.15 7.9 32.75 0.5 55.52 0.5 55.52 23.28 48.12 15.87 23.86 40.14 15.88 48.13 8.48 40.72 8.48 63.5 31.25 63.5 23.85 56.1 49.43 30.5 46.96 28.03"/>
                              </svg>
                              <div class="contract-type">
                                  <h5 class="label">Token transfer</h5>
                                  <h4 class="token uppercase">${token}</h4>
                              </div>
                              <div class="contract-info">
									
									<h5 class="label">Sender</h5>
									<h4 class="address">${sender}</h4>
									<h5 class="label">receiver</h5>
									<h4 class="address">${receiver}</h4>
									<h5 class="label">amount</h5>
                  <h4 class="uppercase">${amount} ${token}</h4>
                  <h5 class="label">Transaction ID</h5>
									<div class="copy-row">
										<h6 class="breakable copy hash">${hash}</h6>
										<svg class="icon" onclick="copyToClipboard(this.parentNode)" viewBox="0 0 54 64">
											<title>Copy</title>
											<path d="M53,0H22.14a6,6,0,0,0-6,6v5H11a6,6,0,0,0-6,6V58a6,6,0,0,0,6,6H41.86a6,6,0,0,0,6-6V53H53a6,6,0,0,0,6-6V6A6,6,0,0,0,53,0ZM43.89,58a2,2,0,0,1-2,2H11a2,2,0,0,1-2-2V17.06a2,2,0,0,1,2-2H41.86a2,2,0,0,1,2,2ZM55,46.94a2,2,0,0,1-2,2H47.89V17.06a6,6,0,0,0-6-6H20.11V6a2,2,0,0,1,2-2H53a2,2,0,0,1,2,2Z" transform="translate(-5)"/>
										</svg>
									</div>
                  </div>`;
				return card;
			},
			tokenCreationCard(obj) {
				let {
					hash,
					blockHeight,
					token,
					incAddress,
					supply
				} = obj,
					card = document.createElement("div");
				card.classList.add("transaction", "token-creation");
				card.id = hash;
				card.innerHTML = `<svg class="icon" viewBox="0 0 64 64">
                                  <title>token</title>
                                  <circle cx="32" cy="32" r="31"/>
                                  <circle cx="32" cy="32" r="25.19"/>
                                  <line x1="37" y1="21.74" x2="43.14" y2="21.74"/>
                                  <path d="M20.86,21.74H32V43.23"/>
                              </svg>
                              <div class="contract-type">
                                  <h5 class="label">token creation</h5>
                                  <h4 class="token uppercase">${token}</h4>
                              </div>
                              <div class="contract-info">
							  	
									<h5 class="label">Incorporation address</h5>
									<h4 class="address">${incAddress}</h4>
									<h5 class="label">token name</h5>
									<h4 class="uppercase">${token}</h4>
									<h5 class="label">supply</h5>
                  <h4>${supply}</h4>
                  <h5 class="label">Transaction ID</h5>
							  	<div class="copy-row">
										<h6 class="breakable copy hash">${hash}</h6>
										<svg class="icon" onclick="copyToClipboard(this.parentNode)" viewBox="0 0 54 64">
											<title>Copy</title>
											<path d="M53,0H22.14a6,6,0,0,0-6,6v5H11a6,6,0,0,0-6,6V58a6,6,0,0,0,6,6H41.86a6,6,0,0,0,6-6V53H53a6,6,0,0,0,6-6V6A6,6,0,0,0,53,0ZM43.89,58a2,2,0,0,1-2,2H11a2,2,0,0,1-2-2V17.06a2,2,0,0,1,2-2H41.86a2,2,0,0,1,2,2ZM55,46.94a2,2,0,0,1-2,2H47.89V17.06a6,6,0,0,0-6-6H20.11V6a2,2,0,0,1,2-2H53a2,2,0,0,1,2,2Z" transform="translate(-5)"/>
										</svg>
                  </div>
                  </div>`;
				return card;
			},
			contractTriggerCard(obj) {
				let {
					hash,
					blockHeight,
					contractName,
					contractAddress,
					winningChoice,
					committeeAddress
				} = obj,
					card = document.createElement("div");
				card.classList.add("transaction", "contract-trigger");
				card.id = hash;
				card.innerHTML = `    <svg class="icon" viewBox="0 0 64 64">
                                  <circle cx="32" cy="32" r="31"/>
                                  <polyline points="32 13.47 32 32 43.4 43.4"/>
                              </svg>
                              <div class="contract-type">
                                  <h5 class="label">smart contract </h5>
                                  <h4 class="uppercase">trigger</h4>
                              </div>
							  
                              <div class="contract-info">
                    
									<h5 class="label">Contract name</h5>
									<h4>${contractName}</h4>
									<h5 class="label">contract address</h5>
									<h4 class="address">${contractAddress}</h4>
									<h5 class="label">Winning Choice</h5>
									<h4>${winningChoice}</h4>
									<h5 class="label">committee address</h5>
                  <h4 class="address">${committeeAddress}</h4>
                  <h5 class="label">Transaction ID</h5>
							  		<div class="copy-row">
										<h6 class="breakable copy hash">${hash}</h6>
										<svg class="icon" onclick="copyToClipboard(this.parentNode)" viewBox="0 0 54 64">
											<title>Copy</title>
											<path d="M53,0H22.14a6,6,0,0,0-6,6v5H11a6,6,0,0,0-6,6V58a6,6,0,0,0,6,6H41.86a6,6,0,0,0,6-6V53H53a6,6,0,0,0,6-6V6A6,6,0,0,0,53,0ZM43.89,58a2,2,0,0,1-2,2H11a2,2,0,0,1-2-2V17.06a2,2,0,0,1,2-2H41.86a2,2,0,0,1,2,2ZM55,46.94a2,2,0,0,1-2,2H47.89V17.06a6,6,0,0,0-6-6H20.11V6a2,2,0,0,1,2-2H53a2,2,0,0,1,2,2Z" transform="translate(-5)"/>
										</svg>
									</div>
                              </div>`;
				return card;
			},
			contractCreationCard(obj) {
				let { hash, blockHeight, token, contractName, incAddress, contractType, expiration, participationFees, availableChoices } = obj,
					card = document.createElement("div");
				card.classList.add("transaction", "contract-creation");
				card.id = hash;
				card.innerHTML = `<svg class="icon" viewBox="0 0 64 64">
                                  <title>contract creation</title>
                                  <path d="M47.07,23.85V11"/>
                                  <path d="M3,47A7,7,0,0,0,.48,52.39a6.89,6.89,0,0,0,2.05,4.93,6.78,6.78,0,0,0,3.78,2,6.34,6.34,0,0,0,1.16.1H40.09a7,7,0,0,0,7-7V44"/>
                                  <path d="M6.31,53V11.61a7,7,0,0,1,7-7H45.91a6.26,6.26,0,0,1,1.16.1,6.74,6.74,0,0,1,3.78,1.95A7,7,0,0,1,50.37,17"/>
                                  <line x1="14.46" y1="23.85" x2="38.92" y2="23.85"/>
                                  <line x1="14.46" y1="32" x2="38.92" y2="32"/>
                                  <line x1="14.46" y1="40.15" x2="31.93" y2="40.15"/>
                                  <path d="M57.79,24.44l-2.88-2.9,3.79-3.79a1,1,0,0,1,1.39,0l3.11,3.11a1,1,0,0,1,0,1.39L40.34,45.1a1,1,0,0,1-.52.28L36,46A1,1,0,0,1,34.9,44.9l.67-3.77a1,1,0,0,1,.27-.52L52.65,23.8"/>
                              </svg>
                              <div class="contract-type">
                                  <h5 class="label">Smart Contract creation</h5>
                                  <h4 class="token uppercase">${token}</h4>
                              </div>
                              <div class="contract-info">
							  		
                                  <h5 class="label">Contract name</h5>
                                  <h4>${contractName}</h4>
                                  <h5 class="label">Contract address</h5>
                                  <h4 class="address">${incAddress}</h4>
                                  <h5 class="label">token used</h5>
                                  <h4 class="uppercase">${token}</h4>
                                  <h5 class="label">contract type</h5>
                                  <h4>${replaceDash(contractType)}</h4>
                                  <h5 class="label">expiration</h5>
                                  <h4 class="capitalise">${expiration}</h4>
                                  <h5 class="label">participation amount</h5>
                                  <h4 class="uppercase">${participationFees} ${token}</h4>
                                  <h5 class="label">Transaction ID</h5>
                                  <div class="copy-row">
                                    <h6 class="breakable copy hash">${hash}</h6>
                                    <svg class="icon" onclick="copyToClipboard(this.parentNode)" viewBox="0 0 54 64">
                                      <title>Copy</title>
                                      <path d="M53,0H22.14a6,6,0,0,0-6,6v5H11a6,6,0,0,0-6,6V58a6,6,0,0,0,6,6H41.86a6,6,0,0,0,6-6V53H53a6,6,0,0,0,6-6V6A6,6,0,0,0,53,0ZM43.89,58a2,2,0,0,1-2,2H11a2,2,0,0,1-2-2V17.06a2,2,0,0,1,2-2H41.86a2,2,0,0,1,2,2ZM55,46.94a2,2,0,0,1-2,2H47.89V17.06a6,6,0,0,0-6-6H20.11V6a2,2,0,0,1,2-2H53a2,2,0,0,1,2,2Z" transform="translate(-5)"/>
                                    </svg>
                                  </div>
                              </div>`;
				return card;
			},
			blockCard(blockHeight, transactions) {
				let card = document.createElement('div'),
					pural = '';
				card.classList.add('card')
				if (parseInt(transactions) > 1)
					pural = 's'
				card.innerHTML = `
          <h4 class="block-height">${blockHeight}</h4>
          <h4>${transactions} Transaction${pural}</h4>`
				return card;
			}
		};

		const pageTitle = document.getElementById("page_title"),
			pageContainer = document.getElementById("page_container"),
			pageHeader = document.getElementById("page_header");
		let prevField = "";

		function removePage() {
			if (pageContainer.firstElementChild)
				pageContainer.firstElementChild.remove();
		}

		function replaceDash(string) {
			return string.replace(/-/g, " ");
		}

		function replaceSpace(str) {
			return str.replace(/ /g, "-");
		}

		function showPage(page){
			document.getElementById(page).classList.remove('hide')
			document.getElementById('page_container').classList.add('hide-completely')
		}
		function hidePage(page){
			document.getElementById(page).classList.add('hide')
			document.getElementById('page_container').classList.remove('hide-completely')
		}

		window.onpopstate = (e) => {
			if (e.state !== null) {
				let {
					page,
					thisField
				} = e.state;
				render(page, thisField);
			}
		};

		async function appendTransactions(container, transactions) {
			let txFrag = await getTxFrag(transactions);
			txFrag.forEach(tx => {
				switch (tx["type"]) {
					case 'tokentransfer':
						frag.append(create.tokenTransferCard(tx))
						break;
					case 'contracttransfer':
						frag.append(create.contractTransferCard(tx));
						break;
					case 'tokenincorp':
						frag.append(create.tokenCreationCard(tx));
						break;

					case 'contractincorp':
						frag.append(create.contractCreationCard(tx));
						break;

					case 'contracttrigger':
						frag.append(create.contractTriggerCard(tx));
						break;
				}
			})
			document.getElementById(container).append(frag);
		}

		async function render(pageId, field) {
			if ("scrollRestoration" in history) {
				history.scrollRestoration = "manual";
			}
			window.scrollTo(0, 0);
			loading(true)
			removePage();

			if (pageId === "address_page") {
				let [addressInfo, addressBalance, addressTxs] = await Promise.all([getAddressInfo(field), getAddressBalance(field), getAddressTxs(field)])
				console.log(addressInfo)
				pageContainer.append(create.addressPage({
					balance: addressBalance,
					address: field
				}))
				pageTitle.textContent = 'Address'
				loading()
				appendTransactions('address_transaction_container', addressTxs)
				for (token in addressInfo) {
					frag.append(create.tokenBalanceCard(token, addressInfo[token].balance))
				}
				document.getElementById('token_balance_container').append(frag)

			}

			if (pageId === "token_page") {
				let [tokenInfo, tokenBalances, tokenTransactions] = await Promise.all([getTokenInfo(field), getTokenBalances(field), getTokenTransactions(field)])
				for (bal in tokenBalances) {
					frag.append(create.addrBalanceCard(bal, tokenBalances[bal], tokenInfo.token))
				}
				pageContainer.append(create.tokenPage(tokenInfo));
				pageTitle.textContent = "Token";
				document.getElementById('token_balance_container').append(frag)
				loading()
				appendTransactions('token_transaction_container', tokenTransactions)
			}

			if (pageId === "contract_page") {
				// todo: load contract variable dynamically
				let contract = {
					name: field.name,
					address: field.address,
				};

				let [contractInfo, contractTransactions, contractParticipants] = await Promise.all([getContractInfo(contract), getContractTransactions(contract), getContractParticipants(contract)])
				// todo : check the type of contract & then further checks like fetching details of contractParticipant 
				pageContainer.append(create.contractPage(contractInfo));
				pageTitle.textContent = "Contract";
				loading()
				console.log(contractParticipants)
				let winners = []
				for (participant in contractParticipants) {
					if (contractParticipants[participant].winningAmount)
						winners.push(contractParticipants[participant])
				}
				// append latest transactions
				appendTransactions('contract_transaction_container', contractTransactions)
				for (participant in contractParticipants) {
					let { participantFloAddress, tokenIdentification, userChoice, tokenAmount } = contractParticipants[participant]
					frag.append(create.contractChoiceCard(participantFloAddress, tokenIdentification, userChoice, tokenAmount))
				}
				document.getElementById('participant_container').append(frag)

				winners.forEach(winner => {
					let { participantFloAddress, tokenIdentification, userChoice, tokenAmount, winningAmount } = winner;
					frag.append(create.contractChoiceCard(participantFloAddress, tokenIdentification, userChoice, tokenAmount, winningAmount))
				})
				document.getElementById('winners_container').append(frag)

			}

			if (pageId === "block_page") {
				let blockInfo = await getBlockInfo(field);
				pageContainer.append(create.blockPage(blockInfo));
				pageTitle.textContent = "block";
				loading()
			}

			if (pageId === "homepage") {
				pageHeader.classList.add("hide-completely");
				let [data, latestTxs, latestBlocks] = await Promise.all([getBannerData(), getLatestTxs(), getAllBlocks(6)])
				pageContainer.append(create.homepage(data));
				loading();

				// getAllSuggestions()

				latestTxs.forEach(tx => {
					if (tx["type"] == "tokentransfer")
						frag.append(create.tokenTransferCard(tx))
					else if (tx["type"] == "contracttransfer")
						frag.append(create.contractTransferCard(tx));
				})
				document.getElementById("top_transaction_container").append(frag);

				// todo - add latest blocks
				for (block in latestBlocks) {
					frag.append(create.blockCard(latestBlocks[block].height, latestBlocks[block].tx.length))
				}
				document.getElementById('top_blocks_container').append(frag)
			} else pageHeader.classList.remove("hide-completely");

			if (pageId === "all_blocks_page") {
				let allBlocks = await getAllBlocks(100);
				pageContainer.append(create.allBlocksPage())
				pageTitle.textContent = "All Blocks";
				for (block in allBlocks) {
					frag.append(create.blockCard(allBlocks[block].height, allBlocks[block].tx.length))
				}
				document.getElementById('all_blocks_page').append(frag)
				loading()
			}

			if (pageId === "all_transactions_page") {
				let allTxs = await getAllTxs();
				pageTitle.textContent = "All Transactions";
				pageContainer.append(create.alltransactionsPage())
				appendTransactions('all_transactions_page', allTxs)
				loading()
			}

			if (pageId === "transaction_page") {
				let txInfo = await getTxInfo(field);
				pageContainer.append(create.transactionPage(txInfo))
				pageTitle.textContent = "transaction";
				loading()
			}
			prevField = field;
			if (pageContainer.querySelector('.tab.active'))
				pageContainer.querySelector('.tab.active').click()
			tabMounted = false;
		}

		window.addEventListener("load", async () => {
			document.getElementById("main_search_field").addEventListener("keydown", function (e) {
				if (e.key === 'Enter') {
					processNavbarSearch();
				}
			});
			let themeToggler = document.getElementById("theme_toggle"),
				body = document.querySelector("body");
			if (localStorage.theme === "dark") {
				nightlight();
				themeToggler.checked = true;
			} else {
				daylight();
				themeToggler.checked = false;
			}

			function daylight() {
				body.setAttribute("data-theme", "light");
			}

			function nightlight() {
				body.setAttribute("data-theme", "dark");
			}
			themeToggler.addEventListener("change", () => {
				if (themeToggler.checked) {
					nightlight();
					localStorage.setItem("theme", "dark");
				} else {
					daylight();
					localStorage.setItem("theme", "light");
				}
			});

			appState = {
				page: "homepage",
				thisField: null,
			};
			history.pushState(appState, null, '');

			var hashvalue = location.hash.slice(1);
			if (hashvalue == '') {

				render("homepage");
				getAllSuggestions();
			}
			else {
				await getAllSuggestions();
				categoriseText(hashvalue);
			}

			this.addEventListener("click", (e) => {

				if (e.target.closest(".address") && prevField !== e.target.textContent) {
					render("address_page", e.target.textContent)
					appState = {
						page: "address_page",
						thisField: e.target.textContent,
					};
					history.pushState(appState, null, `#${e.target.textContent}`)
				}
				if (e.target.closest(".token") && prevField !== e.target.textContent) {
					let tokenname = e.target.textContent.toLowerCase();
					render("token_page", tokenname);
					appState = {
						page: "token_page",
						thisField: tokenname
					};
					history.pushState(appState, null, `#${tokenname}`)
				}
				if (e.target.closest(".hash") && prevField !== e.target.textContent) {
					render("transaction_page", e.target.closest(".transaction").id);
					appState = {
						page: "transaction_page",
						thisField: e.target.closest(".transaction").id,
					};
					history.pushState(appState, null, `#${appState.thisField}`)
				}
				if (e.target.closest(".block-height") && prevField !== e.target.textContent) {
					render("block_page", e.target.textContent);
					appState = {
						page: "block_page",
						thisField: e.target.textContent
					};
					history.pushState(appState, null, `#${e.target.textContent}`);
				}
				if (e.target.closest(".contract") && prevField !== e.target.textContent) {
					let contract = {
						name: e.target.textContent.split(' ').join('-'),
						address: e.target.dataset.contractAddress
					}
					render("contract_page", contract)
					appState = {
						page: "contract_page",
						thisField: { name: contract.name, address: contract.address },
					}
					history.pushState(appState, null, `#${contract.name}-${contract.address}`)
				}
				if (e.target.closest(".tab")) {
					showTab(e.target.closest(".tab"));
				}
				if (e.target.closest("#secondary_search_btn") || e.target.closest("#primary_search")) {
					showPage('search_page')
				}
				if (e.target.closest("#close_search_btn")) {
					hidePage('search_page')
				}
				if (e.target.closest('.suggestion')) {
					let searchBox = document.getElementById('main_search_field');
					searchBox.value = e.target.textContent;
					processNavbarSearch()
				}
				if (e.target.closest('#all_trans_btn')) {
					render('all_transactions_page')
					appState = {
						page: "all_transactions_page",
						thisField: null,
					}
					history.pushState(appState, null, `#viewalltx`)
				}
				if (e.target.closest('#all_blocks_btn')) {
					render('all_blocks_page')
					appState = {
						page: "all_blocks_page",
						thisField: null,
					}
					history.pushState(appState, null, `#viewallblocks`)
				}
			});
		});

		window.addEventListener('input', e => {
			if (e.target.closest('.suggestion') && e.key === 'Enter') {
				processNavbarSearch()
			}
			if (e.target.closest('.suggestion') && e.key === 'Tab') {
				let searchBox = document.getElementById('main_search_field');
				searchBox.value = e.target.textContent;
			}
			if (e.target.closest('#main_search_field')) {
				let results = index.search(e.target.value, 25),
					entry, childs = suggestions.childNodes,
					i = 0,
					len = results.length;
				for (; i < len; i++) {
					entry = childs[i];
					if (!entry && data[results[i]]) {
						suggestions.append(suggestion(data[results[i]]))
					}
				}
				while (childs.length > len) {
					suggestions.removeChild(childs[i])
				}
				suggestions.append(frag)
			}
		})

		let tabMounted = false;

		function showTab(tab) {
			let targetTab = tab.getAttribute('data-target'),
				activeTabRank = parseInt(tab.parentNode.querySelector('.active').dataset.rank),
				currentTabRank = parseInt(tab.dataset.rank),
				currentBody = document.getElementById(tab.parentNode.querySelector('.active').dataset.target),
				targetBody = document.getElementById(targetTab),
				targetGroup = targetBody.dataset.tabGroup,
				tabGroupMembers = document.querySelectorAll(`[data-tab-group = '${targetGroup}']`),
				allTabs = tab.parentNode.querySelectorAll('.tab'),
				line = tab.parentNode.querySelector('.line')
			if (tabMounted && currentBody.isEqualNode(targetBody))
				return
			if (activeTabRank < currentTabRank) {
				targetBody.classList.add('fly-in-from-right')
				currentBody.classList.add('fly-out-to-left')
			} else {
				targetBody.classList.add('fly-in-from-left')
				currentBody.classList.add('fly-out-to-right')
			}
			setTimeout(() => {
				tabGroupMembers.forEach(member => {
					member.classList.add('hide-completely')
				})
				targetBody.classList.remove('hide-completely')
				currentBody.classList.remove('fly-out-to-right', 'fly-out-to-left')
			}, 200)
			setTimeout(() => {
				targetBody.classList.remove('fly-in-from-right', 'fly-in-from-left')
			}, 400)
			allTabs.forEach(thisTab => {
				thisTab.classList.remove('active')
			})
			tab.classList.add('active')
			line.setAttribute('style', `transform: translateX(${tab.offsetLeft}px); width: ${tab.getBoundingClientRect().width}px`)
			tabMounted = true;
		}

		let loader = document.getElementById("loader_page");

		function loading(status) {
			if (status) loader.classList.remove("hide-completely");
			else loader.classList.add("hide-completely");
		}

		function copyToClipboard(parent) {
			let input = document.createElement('textarea'),
				toast = document.getElementById('textCopied'),
				textToCopy = parent.querySelector('.copy');
			input.setAttribute('readonly', '');
			input.setAttribute('style', 'position: absolute; left: -9999px');
			document.body.appendChild(input);
			input.value = textToCopy.textContent;
			input.select();
			document.execCommand('copy');
			document.body.removeChild(input);
			toast.classList.remove('hide');
			setTimeout(() => {
				toast.classList.add('hide');
			}, 2000)
		}

		async function getBannerData() {
			const response = await fetch(`${tokenapiUrl}/api/v1.0/getSystemData`),
				data = await response.json(),
				{ systemTransactionCount, systemAddressCount } = data
			return {
				topToken: "RMT",
				totalTransactions: systemTransactionCount,
				walletAddresses: systemAddressCount,
				topContract: {
					name: "india-elections-2019",
					address: 'F7osBpjDDV1mSSnMNrLudEQQ3cwDJ2dPR1'
				}
			}
		}

		function getLatestTxs() {
			return fetch(
				`${tokenapiUrl}/api/v1.0/getLatestTransactionDetails?numberOfLatestBlocks=4`
			)
				.then(function (response) {
					return response.json();
				})
				.then(function (latestTxs) {
					latestTxArray = [];

					let txids = Object.keys(latestTxs["latestTransactions"]);
					for (let i = 0; i < txids.length; i++) {
						// determine txhash and blockHeight
						let obj = {
							hash: latestTxs["latestTransactions"][txids[i]][
								"transactionDetails"
							]["txid"],
							blockHeight: latestTxs["latestTransactions"][txids[i]][
								"transactionDetails"
							]["blockheight"],
						};

						let txtype =
							latestTxs["latestTransactions"][txids[i]]["parsedFloData"][
							"type"
							];

						if (txtype != "smartContractPays") {
							// determine token
							obj["token"] =
								latestTxs["latestTransactions"][txids[i]]["parsedFloData"][
								"tokenIdentification"
								];

							if (txtype == "transfer") {
								if (
									latestTxs["latestTransactions"][txids[i]]["parsedFloData"][
									"transferType"
									] == "token"
								) {
									// token transfer
									/* tokenTransferCard
																			  hash, blockHeight, token, sender, receiver, amount */

									let receiveraddress = "";
									for (
										let i = 0,
										voutlist =
											latestTxs["latestTransactions"][txids[i]][
											"transactionDetails"
											]["vout"]; i < voutlist.length; i++
									) {
										if (
											voutlist[i]["scriptPubKey"]["addresses"][0] !=
											latestTxs["latestTransactions"][txids[i]][
											"transactionDetails"
											]["vin"][0]["addr"]
										) {
											receiveraddress =
												voutlist[i]["scriptPubKey"]["addresses"][0];
										}
									}

									obj = Object.assign({}, obj, {
										sender: latestTxs["latestTransactions"][txids[i]][
											"transactionDetails"
										]["vin"][0]["addr"],
										receiver: receiveraddress,
										amount: `${
											latestTxs["latestTransactions"][txids[i]][
											"parsedFloData"
											]["tokenAmount"]
											}`,
										type: "tokentransfer",
									});
									latestTxArray.push(obj);
								} else if (
									latestTxs["latestTransactions"][txids[i]]["parsedFloData"][
									"transferType"
									] == "smartContract"
								) {
									// smart contract transfer
									let receiveraddress = "";
									for (
										let i = 0,
										voutlist =
											latestTxs["latestTransactions"][txids[i]][
											"transactionDetails"
											]["vout"]; i < voutlist.length; i++
									) {
										if (
											voutlist[i]["scriptPubKey"]["addresses"][0] !=
											latestTxs["latestTransactions"][txids[i]][
											"transactionDetails"
											]["vin"][0]["addr"]
										) {
											receiveraddress =
												voutlist[i]["scriptPubKey"]["addresses"][0];
										}
									}

									obj = Object.assign({}, obj, {
										sender: latestTxs["latestTransactions"][txids[i]][
											"transactionDetails"
										]["vin"][0]["addr"],
										receiver: receiveraddress,
										amount: `${
											latestTxs["latestTransactions"][txids[i]][
											"parsedFloData"
											]["tokenAmount"]
											}`,
										contractName: `${
											latestTxs["latestTransactions"][txids[i]][
											"parsedFloData"
											]["contractName"]
											}`,
										userChoice: `${
											latestTxs["latestTransactions"][txids[i]][
											"parsedFloData"
											]["userChoice"]
											}`,
										type: "contracttransfer",
									});
									latestTxArray.push(obj);
								}
							} else if (
								latestTxs["latestTransactions"][txids[i]]["parsedFloData"][
								"type"
								] == "smartContractIncorporation"
							) {
								// smart contract incorporation
								// todo : add checks to determine obj for different types of smart contract incorporation
								obj = Object.assign({}, obj, {
									contractName: latestTxs["latestTransactions"][txids[i]][
										"parsedFloData"
									]["contractName"],
									incAddress: latestTxs["latestTransactions"][txids[i]][
										"parsedFloData"
									]["contractAddress"],
									contractType: latestTxs["latestTransactions"][txids[i]][
										"parsedFloData"
									]["contractType"],
									expiration: latestTxs["latestTransactions"][txids[i]][
										"parsedFloData"
									]["contractConditions"]["expiryTime"],
									participationFees: latestTxs["latestTransactions"][txids[i]][
										"parsedFloData"
									]["contractConditions"]["contractAmount"],
									availableChoices: "",
									type: "contractincorp",
								});
								latestTxArray.push(obj);
							} else if (
								latestTxs["latestTransactions"][txids[i]]["parsedFloData"][
								"type"
								] == "tokenIncorporation"
							) {
								// token incorporation
								// smart contract incorporation
								obj = Object.assign({}, obj, {
									incAddress: latestTxs["latestTransactions"][txids[i]][
										"transactionDetails"
									]["vin"][0]["addr"],
									supply: latestTxs["latestTransactions"][txids[i]][
										"parsedFloData"
									]["tokenAmount"],
									type: "tokenincorp",
								});
								latestTxArray.push(obj);
							}
						} else {
							// smart contract committee trigger
							// smart contract incorporation
							let receiveraddress = "";
							for (
								let i = 0,
								voutlist =
									latestTxs["latestTransactions"][txids[i]][
									"transactionDetails"
									]["vout"]; i < voutlist.length; i++
							) {
								if (
									voutlist[i]["scriptPubKey"]["addresses"][0] !=
									latestTxs["latestTransactions"][txids[i]][
									"transactionDetails"
									]["vin"][0]["addr"]
								) {
									receiveraddress =
										voutlist[i]["scriptPubKey"]["addresses"][0];
								}
							}
							obj = Object.assign({}, obj, {
								contractName: latestTxs["latestTransactions"][txids[i]]["parsedFloData"][
									"contractName"
								],
								contractAddress: receiveraddress,
								winningChoice: latestTxs["latestTransactions"][txids[i]]["parsedFloData"][
									"triggerCondition"
								],
								committeeAddress: latestTxs["latestTransactions"][txids[i]][
									"transactionDetails"
								]["vin"][0]["addr"],
								type: "contracttrigger",
							});
							latestTxArray.push(obj);
						}
					}
					return latestTxArray;
				});
		}

		function getLatestBlocks() {
			return fetch(
				`${tokenapiUrl}/api/v1.0/getLatestBlockDetails?numberOfLatestBlocks=4`
			)
				.then(function (response) {
					return response.json();
				})
				.then(function (latestBlocks) {
					let obj = {};
					return obj;
				});
		}

		function getTokenInfo(thisToken) {
			return fetch(
				`${tokenapiUrl}/api/v1.0/getTokenInfo?token=${thisToken.toLowerCase()}`
			)
				.then(function (response) {
					return response.json();
				})
				.then(function (tokenInfo) {
					let associatedSC = {};
					for (let i = 0, associatedScList = tokenInfo["associatedSmartContracts"]; i < associatedScList.length; i++) {
						associatedSC[`${associatedScList[i]["contractName"]}-${associatedScList[i]["contractAddress"]}`] = associatedScList[i];
					}
					let obj = {
						token: tokenInfo["token"],
						supply: tokenInfo["tokenSupply"],
						incAddress: tokenInfo["incorporationAddress"],
						associatedContracts: associatedSC,
						blockchainReference: tokenInfo["blockchainReference"],
					};
					return obj;
				});
		}

		async function getTokenBalances(tokenName) {
			const response = await fetch(`${tokenapiUrl}/api/v1.0/getTokenBalances?token=` + tokenName),
				messeges = await response.json()
			return messeges.balances
		}

		async function getTokenTransactions(tokenName) {
			const response = await fetch(`${tokenapiUrl}/api/v1.0/getTokenTransactions?token=` + tokenName),
				transactions = await response.json()
			return transactions.transactions

		}

		async function getBlockInfo(thisBlock) {
			const response = await fetch(`${tokenapiUrl}/api/v1.0/getBlockDetails/${thisBlock}`),
				info = await response.json(),
				{ height, size, reward, hash, difficulty, nonce } = info.blockDetails
			return {
				blockHeight: height,
				size: size,
				transactions: "",
				reward: reward,
				hash: hash,
				difficulty: difficulty,
				nonce: nonce,
			}
		}

		async function getContractInfo(contract) {
			const response = await fetch(`${tokenapiUrl}/api/v1.0/getSmartContractInfo?contractName=${contract.name}&contractAddress=${contract.address}`),
				info = await response.json(),
				{
					contractInfo,
					contractAddress,
					contractName
				} = info
			return {
				contract: contractName,
				contractAddress: contractAddress,
				contractType: contractInfo.contractType,
				status: contractInfo.status,
				expiration: contractInfo?.expiryTime,
				payeeAddress: contractInfo?.payeeAddress,
				userChoices: contractInfo?.userChoice,
				token: contractInfo?.tokenIdentification,
				participationFees: contractInfo?.contractAmount,
				minAmount: contractInfo?.minimumsubscriptionamount,
				maxAmount: contractInfo?.maximumsubscriptionamount
			}
		}

		async function getContractParticipants(contract) {
			const response = await fetch(`${tokenapiUrl}/api/v1.0/getSmartContractParticipants?contractName=${contract.name}&contractAddress=${contract.address}`),
				participants = await response.json()
			return participants.participantInfo
		}

		async function getContractTransactions(contract) {
			const response = await fetch(`${tokenapiUrl}/api/v1.0/getSmartContractTransactions?contractName=${contract.name}&contractAddress=${contract.address}`),
				transactions = await response.json()
			return transactions.contractTransactions
		}

		async function getTxFrag(txList) {
			// Check if "txList" is array or object
			if (!Array.isArray(txList)) {
				// Object
				latestTxArray = [];

				let txids = Object.keys(txList);
				for (let i = 0; i < txids.length; i++) {
					let obj = {
						hash: txList[txids[i]]["transactionDetails"]["txid"],
						blockHeight: txList[txids[i]]["transactionDetails"]["blockheight"],
					};

					let txtype = txList[txids[i]]["parsedFloData"]["type"];

					if (txtype != "smartContractPays") {
						// determine token
						obj["token"] = txList[txids[i]]["parsedFloData"]["tokenIdentification"];
						switch (txtype) {
							case 'transfer':
								let transferType = txList[txids[i]]["parsedFloData"]["transferType"]
								if (transferType == "token") {
									let receiveraddress = "";
									for (
										let i = 0,
										voutlist =
											txList[txids[i]][
											"transactionDetails"
											]["vout"]; i < voutlist.length; i++
									) {
										if (
											voutlist[i]["scriptPubKey"]["addresses"][0] !=
											txList[txids[i]][
											"transactionDetails"
											]["vin"][0]["addr"]
										) {
											receiveraddress =
												voutlist[i]["scriptPubKey"]["addresses"][0];
										}
									}

									obj = Object.assign({}, obj, {
										sender: txList[txids[i]][
											"transactionDetails"
										]["vin"][0]["addr"],
										receiver: receiveraddress,
										amount: `${
											txList[txids[i]][
											"parsedFloData"
											]["tokenAmount"]
											}`,
										type: "tokentransfer",
									});
									latestTxArray.push(obj);
									break;

								}

								if (transferType == 'smartContract') {
									// smart contract transfer
									let receiveraddress = "";
									for (
										let i = 0,
										voutlist =
											txList[txids[i]][
											"transactionDetails"
											]["vout"];
										i < voutlist.length;
										i++
									) {
										if (
											voutlist[i]["scriptPubKey"]["addresses"][0] !=
											txList[txids[i]][
											"transactionDetails"
											]["vin"][0]["addr"]
										) {
											receiveraddress =
												voutlist[i]["scriptPubKey"]["addresses"][0];
										}
									}

									obj = Object.assign({}, obj, {
										sender:
											txList[txids[i]][
											"transactionDetails"
											]["vin"][0]["addr"],
										receiver: receiveraddress,
										amount: `${
											txList[txids[i]][
											"parsedFloData"
											]["tokenAmount"]
											}`,
										contractName: `${
											txList[txids[i]][
											"parsedFloData"
											]["contractName"]
											}`,
										userChoice: `${
											txList[txids[i]][
											"parsedFloData"
											]["userChoice"]
											}`,
										type: "contracttransfer",
									});
									latestTxArray.push(obj);
									break;

								}

							case 'tokenIncorporation':
								// token incorporation
								// smart contract incorporation
								obj = Object.assign({}, obj, {
									incAddress:
										txList[txids[i]][
										"transactionDetails"
										]["vin"][0]["addr"],
									supply:
										txList[txids[i]][
										"parsedFloData"
										]["tokenAmount"],
									type: "tokenincorp",
								});
								latestTxArray.push(obj);
								break;

							case 'smartContractIncorporation':
								// smart contract incorporation
								// todo : add checks to determine obj for different types of smart contract incorporation
								obj = Object.assign({}, obj, {
									contractName:
										txList[txids[i]][
										"parsedFloData"
										]["contractName"],
									incAddress:
										txList[txids[i]][
										"parsedFloData"
										]["contractAddress"],
									contractType:
										txList[txids[i]][
										"parsedFloData"
										]["contractType"],
									expiration:
										txList[txids[i]][
										"parsedFloData"
										]["contractConditions"]["expiryTime"],
									participationFees:
										txList[txids[i]][
										"parsedFloData"
										]["contractConditions"]["contractAmount"],
									availableChoices: "",
									type: "contractincorp",
								});
								latestTxArray.push(obj);
								break;
						}

					} else {
						// transaction is a FLO Smart Contract Committe trigger

						let receiver = "", sender = txList[txids[i]]['transactionDetails']['vin'][0]['addr'], vout = txList[txids[i]]['transactionDetails']['vout'], vin = txList[txids[i]]['transactionDetails']['vin'];
						for (let i = 0; i < vout.length; i++) {
							if (vout[i]["scriptPubKey"]["addresses"][0] !== vin[0]["addr"]) {
								receiver = vout[i]["scriptPubKey"]["addresses"][0];
							}
						}

						obj = Object.assign({}, obj, {
							hash: txList[txids[i]]['txid'],
							blockHeight: txList[txids[i]]['transactionDetails']['blockheight'],
							contractName: txList[txids[i]]['parsedFloData']['contractName'],
							contractAddress: receiver,
							winningChoice: txList[txids[i]]['parsedFloData']['triggerCondition'],
							committeeAddress: sender,
							type: 'contracttrigger'
						});

						latestTxArray.push(obj);

					}
				}

				return latestTxArray;
			} else {
				// Array

			}
		}

		async function getAllBlocks(number) {
			const response = await fetch(`${tokenapiUrl}/api/v1.0/getLatestBlockDetails?limit=${number}`),
				allBlocks = await response.json()
			return allBlocks.latestBlocks
		}

		async function getAllTxs() {
			const response = await fetch(`${tokenapiUrl}/api/v1.0/getLatestTransactionDetails?limit=200`),
				allTxs = await response.json()
			return allTxs.latestTransactions
		}

		async function getAddressInfo(floAddress) {
			const response = await fetch(`${tokenapiUrl}/api/v1.0/getFloAddressInfo?floAddress=${floAddress}`),
				addressInfo = await response.json()
			return addressInfo.floAddressBalances
		}

		async function getAddressBalance(floAddress) {
			const response = await fetch(`${floapiUrl}/api/addr/${floAddress}/balance`),
				balance = await response.json()
			return balance;
		}

		async function getAddressTxs(floAddress) {
			const response = await fetch(`${tokenapiUrl}/api/v1.0/getFloAddressTransactions?floAddress=${floAddress}`),
				transactions = await response.json()
			return transactions.transactions
		}

		async function getTxInfo(thisTx) {
			const response = await fetch(`${tokenapiUrl}/api/v1.0/getTransactionDetails/${thisTx}`),
				transaction = await response.json(),
				transactionHash = transaction.transactionHash,
				{ flodata, tokenAmount, tokenIdentification, type } = transaction.parsedFloData,
				{ blockheight, vin, vout, confirmations } = transaction.transactionDetails;
			let receiver = "",
				sender = vin[0].addr;
			for (let i = 0; i < vout.length; i++) {
				if (vout[i]["scriptPubKey"]["addresses"][0] !== vin[0]["addr"]) {
					receiver = vout[i]["scriptPubKey"]["addresses"][0];
				}
			}
			console.log(transaction)
			return {
				type: `${transaction.parsedFloData?.transferType} ${type}`,
				name: tokenIdentification,
				blockHeight: blockheight,
				amount: tokenAmount,
				sender: sender,
				receiver: receiver,
				floData: flodata,
				hash: transactionHash,
				confirmations: confirmations
			}
		}


		// THIS TAG CONTAINS CODE REQUIRED FOR THE NAVBAR TO FUNCTION
		function returnHexaNumber(s) {
			var regExp = /^[-+]?[0-9A-Fa-f]+\.?[0-9A-Fa-f]*?$/;
			return (typeof s === 'string' && regExp.test(s));
		}

		function isInt(n) {
			return Number(n) === n && n % 1 === 0;
		}

		function isFloat(n) {
			return Number(n) === n && n % 1 !== 0;
		}

		function splitContractNameAddress(value, index) {
			var tempObj = {};
			tempObj['name'] = value.substring(0, index);
			tempObj['address'] = value.substring(index + 1);
			return tempObj
		}

		function categoriseText(text, metadata = null) {
			if (!isNaN(text) && isInt(Number(text))) {
				//console.log('this is a block number');
				render("block_page", text);
				appState = {
					page: "block_page",
					thisField: text,
				}
				history.pushState(appState, null, `#${text}`)
			} else if (typeof (text) == 'string') {
				if (text.length == 34 && text[0] == 'F') {
					//console.log('data entered is a FLO address');
					render("address_page", text)
					appState = {
						page: "address_page",
						thisField: text,
					}
					history.pushState(appState, null, `#${text}`)
				} else if (window.ranchimallflo.tokenlist.includes(text.toLowerCase())) {
					//console.log('data entered is a token name');
					text = text.toLowerCase()
					render("token_page", text)
					appState = {
						page: "token_page",
						thisField: text,
					}
					history.pushState(appState, null, `#${text}`)
				} else if (window.ranchimallflo.smartcontractnameaddresslist.includes(text)) {

					var contractSplit = splitContractNameAddress(text, text.lastIndexOf('-'));

					render("contract_page", contract = {
						name: contractSplit.name,
						address: contractSplit.address
					})
					appState = {
						page: "contract_page",
						thisField: text,
					}
					history.pushState(appState, null, `#${text}`)
					/*for (var i = 0; i < window.ranchimallflo.smartcontractnameaddresslist.length; i++) {

						var contractSplit = splitContractNameAddress(window.ranchimallflo.smartcontractnameaddresslist[i], window.ranchimallflo.smartcontractnameaddresslist[i].lastIndexOf('-'));

						if (window.ranchimallflo.smartcontractnamelist.includes(text)) {
              
						}
					}*/


				} else if (text.length == 64 && returnHexaNumber(text)) {

					fetch(`${window.tokenapiUrl}/api/v1.0/categoriseString/` + text)
						.then(function (response) {
							return response.json();
						})
						.then(function (myJson) {
							if (myJson['type'] == 'transaction') {
								//console.log('data entered is a transaction hash');
								render("transaction_page", text);
								appState = {
									page: "transaction_page",
									thisField: text,
								}
								history.pushState(appState, null, `#${text}`)
							} else if (myJson['type'] == 'block') {
								//console.log('data entered is a block hash');
								render("block_page", text)
								appState = {
									page: "block_page",
									thisField: text,
								}
								history.pushState(appState, null, `#${text}`)
							} else {
								//console.log('data entered is noise');
							}
						});

				} else {
					//console.log('data entered is noise')
				}

			}
		}

		function processNavbarSearch() {
			userinput = document.getElementById('main_search_field');
			if (userinput.value != '') {
				categoriseText(userinput.value, userinput);
			}
		}

		async function getAllSuggestions() {
			window.data = [];
			window.ranchimallflo = {};
			let response = await fetch(`${window.tokenapiUrl}/api/v1.0/getTokenSmartContractList`);
			let myJson = await response.json();

			//console.log('first line of the fetch result');
			ranchimallflo.tokenlist = myJson['tokens'];
			ranchimallflo.smartcontractlist = myJson['smartContracts'];
			ranchimallflo.smartcontractnamelist = [];
			ranchimallflo.smartcontractnameaddresslist = [];
			//console.log(ranchimallflo.smartcontractlist.length);
			for (var i = 0; i < ranchimallflo.smartcontractlist.length; i++) {
				//ranchimallflo.smartcontractnamelist.append(ranchimallflo.smartcontractlist[i]['contractName']);
				data.push(`${ranchimallflo.smartcontractlist[i]['contractName']}-${ranchimallflo.smartcontractlist[i]['contractAddress']}`);
				ranchimallflo.smartcontractnamelist.push(ranchimallflo.smartcontractlist[i]['contractName']);
				ranchimallflo.smartcontractnameaddresslist.push(`${ranchimallflo.smartcontractlist[i]['contractName']}-${ranchimallflo.smartcontractlist[i]['contractAddress']}`);
			}

			for (var i = 0; i < ranchimallflo.tokenlist.length; i++) {
				//ranchimallflo.smartcontractnamelist.append(ranchimallflo.smartcontractlist[i]['contractName']);
				data.push(ranchimallflo.tokenlist[i]);
			}

			window.index = new FlexSearch({
				encode: "advanced",
				tokenize: "reverse",
				suggest: true
			});

			for (var i = 0; i < data.length; i++) {
				index.add(i, data[i]);
			}

			window.suggestion = function (str) {
				let li = document.createElement('li')
				li.textContent = str
				li.tabIndex = 0
				li.classList.add('suggestion')
				return li;
			}

		}

	</script>

	<!-- Flex search content -->
	<script>
		/*
																									 FlexSearch v0.6.22
																									 Copyright 2019 Nextapps GmbH
																									 Author: Thomas Wilkerling
																									 Released under the Apache 2.0 Licence
																									 https://github.com/nextapps-de/flexsearch
																									*/
		//FlexSearch min mode
		DEBUG = true;
		'use strict';
		(function (I, R, v) {
			let K;
			(K = v.define) && K.amd ? K([], function () {
				return R
			}) : (K = v.modules) ? K[I.toLowerCase()] = R : "object" === typeof exports ? module.exports = R : v[I] = R
		})("FlexSearch", function ma(I) {
			function v(a, b) {
				const c = b ? b.id : a && a.id;
				this.id = c || 0 === c ? c : na++;
				this.init(a, b);
				fa(this, "index", function () {
					return this.a ? Object.keys(this.a.index[this.a.keys[0]].c) : Object.keys(this.c)
				});
				fa(this, "length", function () {
					return this.index.length
				})
			}

			function K(a, b, c, d) {
				this.u !== this.g && (this.o = this.o.concat(c), this.u++,
					d && this.o.length >= d && (this.u = this.g), this.u === this.g && (this.cache && this.l.set(b, this.o), this.F && this.F(this.o)));
				return this
			}

			function S(a) {
				const b = B();
				for (const c in a)
					if (a.hasOwnProperty(c)) {
						const d = a[c];
						b[c] = E(d) ? d.slice(0) : J(d) ? S(d) : d
					}
				return b
			}

			function W(a, b) {
				const c = a.length,
					d = O(b),
					e = [];
				for (let f = 0, g = 0; f < c; f++) {
					const h = a[f];
					if (d && b(h) || !d && !b[h]) e[g++] = h
				}
				return e
			}

			function P(a, b, c, d, e, f, g, h, l, m) {
				c = ha(c, g ? 0 : e, h, f, b, l, m);
				let n;
				h && (h = c.page, n = c.next, c = c.result);
				if (g) b = this.where(g, null, e, c);
				else {
					b =
						c;
					c = this.h;
					e = b.length;
					f = Array(e);
					for (g = 0; g < e; g++) f[g] = c[b[g]];
					b = f
				}
				c = b;
				d && (O(d) || (L = d.split(":"), 1 < L.length ? d = oa : (L = L[0], d = pa)), c.sort(d));
				c = T(h, n, c);
				this.cache && this.l.set(a, c);
				return c
			}

			function fa(a, b, c) {
				Object.defineProperty(a, b, {
					get: c
				})
			}

			function q(a) {
				return new RegExp(a, "g")
			}

			function Q(a, b) {
				for (let c = 0; c < b.length; c += 2) a = a.replace(b[c], b[c + 1]);
				return a
			}

			function V(a, b, c, d, e, f, g, h) {
				if (b[c]) return b[c];
				e = e ? (h - (g || h / 1.5)) * f + (g || h / 1.5) * e : f;
				b[c] = e;
				e >= g && (a = a[h - (e + .5 >> 0)], a = a[c] || (a[c] = []), a[a.length] =
					d);
				return e
			}

			function ba(a, b) {
				if (a) {
					const c = Object.keys(a);
					for (let d = 0, e = c.length; d < e; d++) {
						const f = c[d],
							g = a[f];
						if (g)
							for (let h = 0, l = g.length; h < l; h++)
								if (g[h] === b) {
									1 === l ? delete a[f] : g.splice(h, 1);
									break
								} else J(g[h]) && ba(g[h], b)
					}
				}
			}

			function ca(a) {
				let b = "",
					c = "";
				var d = "";
				for (let e = 0; e < a.length; e++) {
					const f = a[e];
					if (f !== c)
						if (e && "h" === f) {
							if (d = "a" === d || "e" === d || "i" === d || "o" === d || "u" === d || "y" === d, ("a" === c || "e" === c || "i" === c || "o" === c || "u" === c || "y" === c) && d || " " === c) b += f
						} else b += f;
					d = e === a.length - 1 ? "" : a[e + 1];
					c = f
				}
				return b
			}

			function qa(a, b) {
				a = a.length - b.length;
				return 0 > a ? 1 : a ? -1 : 0
			}

			function pa(a, b) {
				a = a[L];
				b = b[L];
				return a < b ? -1 : a > b ? 1 : 0
			}

			function oa(a, b) {
				const c = L.length;
				for (let d = 0; d < c; d++) a = a[L[d]], b = b[L[d]];
				return a < b ? -1 : a > b ? 1 : 0
			}

			function T(a, b, c) {
				return a ? {
					page: a,
					next: b ? "" + b : null,
					result: c
				} : c
			}

			function ha(a, b, c, d, e, f, g) {
				let h, l = [];
				if (!0 === c) {
					c = "0";
					var m = ""
				} else m = c && c.split(":");
				const n = a.length;
				if (1 < n) {
					const y = B(),
						r = [];
					let w, x;
					var p = 0,
						k;
					let G;
					var u = !0;
					let C, D = 0,
						N, da, X, ea;
					m && (2 === m.length ? (X = m, m = !1) : m = ea = parseInt(m[0], 10));
					if (g) {
						for (w = B(); p < n; p++)
							if ("not" === e[p])
								for (x = a[p], G = x.length, k = 0; k < G; k++) w["@" + x[k]] = 1;
							else da = p + 1;
						if (H(da)) return T(c, h, l);
						p = 0
					} else N = M(e) && e;
					let Y;
					for (; p < n; p++) {
						const ra = p === (da || n) - 1;
						if (!N || !p)
							if ((k = N || e && e[p]) && "and" !== k)
								if ("or" === k) Y = !1;
								else continue;
							else Y = f = !0;
						x = a[p];
						if (G = x.length) {
							if (u)
								if (C) {
									var t = C.length;
									for (k = 0; k < t; k++) {
										u = C[k];
										var A = "@" + u;
										g && w[A] || (y[A] = 1, f || (l[D++] = u))
									}
									C = null;
									u = !1
								} else {
									C = x;
									continue
								}
							A = !1;
							for (k = 0; k < G; k++) {
								t = x[k];
								var z = "@" + t;
								const Z = f ? y[z] || 0 : p;
								if (!(!Z && !d || g && w[z] || !f &&
									y[z]))
									if (Z === p) {
										if (ra) {
											if (!ea || --ea < D)
												if (l[D++] = t, b && D === b) return T(c, D + (m || 0), l)
										} else y[z] = p + 1;
										A = !0
									} else d && (z = r[Z] || (r[Z] = []), z[z.length] = t)
							}
							if (Y && !A && !d) break
						} else if (Y && !d) return T(c, h, x)
					}
					if (C)
						if (p = C.length, g)
							for (k = m ? parseInt(m, 10) : 0; k < p; k++) a = C[k], w["@" + a] || (l[D++] = a);
						else l = C;
					if (d)
						for (D = l.length, X ? (p = parseInt(X[0], 10) + 1, k = parseInt(X[1], 10) + 1) : (p = r.length, k = 0); p--;)
							if (t = r[p]) {
								for (G = t.length; k < G; k++)
									if (d = t[k], !g || !w["@" + d])
										if (l[D++] = d, b && D === b) return T(c, p + ":" + k, l);
								k = 0
							}
				} else !n || e && "not" === e[0] ||
					(l = a[0], m && (m = parseInt(m[0], 10)));
				b && (g = l.length, m && m > g && (m = 0), m = m || 0, h = m + b, h < g ? l = l.slice(m, h) : (h = 0, m && (l = l.slice(m))));
				return T(c, h, l)
			}

			function M(a) {
				return "string" === typeof a
			}

			function E(a) {
				return a.constructor === Array
			}

			function O(a) {
				return "function" === typeof a
			}

			function J(a) {
				return "object" === typeof a
			}

			function H(a) {
				return "undefined" === typeof a
			}

			function ia(a) {
				const b = Array(a);
				for (let c = 0; c < a; c++) b[c] = B();
				return b
			}

			function B() {
				return Object.create(null)
			}

			function sa() {
				let a, b;
				self.onmessage = function (c) {
					if (c =
						c.data)
						if (c.search) {
							const d = b.search(c.content, c.threshold ? {
								limit: c.limit,
								threshold: c.threshold,
								where: c.where
							} : c.limit);
							self.postMessage({
								id: a,
								content: c.content,
								limit: c.limit,
								result: d
							})
						} else c.add ? b.add(c.id, c.content) : c.update ? b.update(c.id, c.content) : c.remove ? b.remove(c.id) : c.clear ? b.clear() : c.info ? (c = b.info(), c.worker = a, console.log(c)) : c.register && (a = c.id, c.options.cache = !1, c.options.async = !1, c.options.worker = !1, b = (new Function(c.register.substring(c.register.indexOf("{") + 1, c.register.lastIndexOf("}"))))(),
							b = new b(c.options))
				}
			}

			function ta(a, b, c, d) {
				a = I("flexsearch", "id" + a, sa, function (f) {
					(f = f.data) && f.result && d(f.id, f.content, f.result, f.limit, f.where, f.cursor, f.suggest)
				}, b);
				const e = ma.toString();
				c.id = b;
				a.postMessage({
					register: e,
					options: c,
					id: b
				});
				return a
			}
			const F = {
				encode: "icase",
				f: "forward",
				split: /\W+/,
				cache: !1,
				async: !1,
				g: !1,
				D: !1,
				a: !1,
				b: 9,
				threshold: 0,
				depth: 0
			},
				ja = {
					memory: {
						encode: "extra",
						f: "strict",
						threshold: 0,
						b: 1
					},
					speed: {
						encode: "icase",
						f: "strict",
						threshold: 1,
						b: 3,
						depth: 2
					},
					match: {
						encode: "extra",
						f: "full",
						threshold: 1,
						b: 3
					},
					score: {
						encode: "extra",
						f: "strict",
						threshold: 1,
						b: 9,
						depth: 4
					},
					balance: {
						encode: "balance",
						f: "strict",
						threshold: 0,
						b: 3,
						depth: 3
					},
					fast: {
						encode: "icase",
						f: "strict",
						threshold: 8,
						b: 9,
						depth: 1
					}
				},
				aa = [];
			let na = 0;
			const ka = {},
				la = {};
			v.create = function (a, b) {
				return new v(a, b)
			};
			v.registerMatcher = function (a) {
				for (const b in a) a.hasOwnProperty(b) && aa.push(q(b), a[b]);
				return this
			};
			v.registerEncoder = function (a, b) {
				U[a] = b.bind(U);
				return this
			};
			v.registerLanguage = function (a, b) {
				ka[a] = b.filter;
				la[a] = b.stemmer;
				return this
			};
			v.encode =
				function (a, b) {
					return U[a](b)
				};
			v.prototype.init = function (a, b) {
				this.v = [];
				if (b) {
					var c = b.preset;
					a = b
				} else a || (a = F), c = a.preset;
				b = {};
				M(a) ? (b = ja[a], a = {}) : c && (b = ja[c]);
				if (c = a.worker)
					if ("undefined" === typeof Worker) a.worker = !1, this.m = null;
					else {
						var d = parseInt(c, 10) || 4;
						this.C = -1;
						this.u = 0;
						this.o = [];
						this.F = null;
						this.m = Array(d);
						for (var e = 0; e < d; e++) this.m[e] = ta(this.id, e, a, K.bind(this))
					}
				this.f = a.tokenize || b.f || this.f || F.f;
				this.split = a.split || this.split || F.split;
				this.D = a.rtl || this.D || F.D;
				this.async = "undefined" === typeof Promise ||
					H(c = a.async) ? this.async || F.async : c;
				this.g = H(c = a.worker) ? this.g || F.g : c;
				this.threshold = H(c = a.threshold) ? b.threshold || this.threshold || F.threshold : c;
				this.b = H(c = a.resolution) ? c = b.b || this.b || F.b : c;
				c <= this.threshold && (this.b = this.threshold + 1);
				this.depth = "strict" !== this.f || H(c = a.depth) ? b.depth || this.depth || F.depth : c;
				this.w = (c = H(c = a.encode) ? b.encode || F.encode : c) && U[c] && U[c].bind(U) || (O(c) ? c : this.w || !1);
				(c = a.matcher) && this.addMatcher(c);
				if (c = (b = a.lang) || a.filter) {
					M(c) && (c = ka[c]);
					if (E(c)) {
						d = this.w;
						e = B();
						for (var f =
							0; f < c.length; f++) {
							var g = d ? d(c[f]) : c[f];
							e[g] = 1
						}
						c = e
					}
					this.filter = c
				}
				if (c = b || a.stemmer) {
					var h;
					b = M(c) ? la[c] : c;
					d = this.w;
					e = [];
					for (h in b) b.hasOwnProperty(h) && (f = d ? d(h) : h, e.push(q(f + "($|\\W)"), d ? d(b[h]) : b[h]));
					this.stemmer = h = e
				}
				this.a = e = (c = a.doc) ? S(c) : this.a || F.a;
				this.j = ia(this.b - (this.threshold || 0));
				this.i = B();
				this.c = B();
				if (e) {
					this.h = B();
					a.doc = null;
					h = e.index = {};
					b = e.keys = [];
					d = e.field;
					f = e.tag;
					E(e.id) || (e.id = e.id.split(":"));
					if (f) {
						this.G = B();
						g = B();
						if (d)
							if (M(d)) g[d] = a;
							else if (E(d))
								for (let l = 0; l < d.length; l++) g[d[l]] =
									a;
							else J(d) && (g = d);
						E(f) || (e.tag = f = [f]);
						for (d = 0; d < f.length; d++) this.G[f[d]] = B();
						this.I = f;
						d = g
					}
					if (d) {
						let l;
						E(d) || (J(d) ? (l = d, e.field = d = Object.keys(d)) : e.field = d = [d]);
						for (e = 0; e < d.length; e++) f = d[e], E(f) || (l && (a = l[f]), b[e] = f, d[e] = f.split(":")), h[f] = new v(a), h[f].h = this.h
					}
				}
				this.B = !0;
				this.l = (this.cache = c = H(c = a.cache) ? this.cache || F.cache : c) ? new ua(c) : !1;
				return this
			};
			v.prototype.encode = function (a) {
				a && aa.length && (a = Q(a, aa));
				a && this.v.length && (a = Q(a, this.v));
				a && this.w && (a = this.w(a));
				a && this.stemmer && (a = Q(a, this.stemmer));
				return a
			};
			v.prototype.addMatcher = function (a) {
				const b = this.v;
				for (const c in a) a.hasOwnProperty(c) && b.push(q(c), a[c]);
				return this
			};
			v.prototype.add = function (a, b, c, d, e) {
				if (this.a && J(a)) return this.A("add", a, b);
				if (b && M(b) && (a || 0 === a)) {
					var f = "@" + a;
					if (this.c[f] && !d) return this.update(a, b);
					if (this.g) return ++this.C >= this.m.length && (this.C = 0), this.m[this.C].postMessage({
						add: !0,
						id: a,
						content: b
					}), this.c[f] = "" + this.C, c && c(), this;
					if (!e) {
						if (this.async && "function" !== typeof importScripts) {
							let r = this;
							f = new Promise(function (w) {
								setTimeout(function () {
									r.add(a,
										b, null, d, !0);
									r = null;
									w()
								})
							});
							if (c) f.then(c);
							else return f;
							return this
						}
						if (c) return this.add(a, b, null, d, !0), c(), this
					}
					b = this.encode(b);
					if (!b.length) return this;
					c = this.f;
					e = O(c) ? c(b) : b.split(this.split);
					this.filter && (e = W(e, this.filter));
					const p = B();
					p._ctx = B();
					const k = e.length,
						u = this.threshold,
						t = this.depth,
						A = this.b,
						z = this.j,
						y = this.D;
					for (let r = 0; r < k; r++) {
						var g = e[r];
						if (g) {
							var h = g.length,
								l = (y ? r + 1 : k - r) / k,
								m = "";
							switch (c) {
								case "reverse":
								case "both":
									for (var n = h; --n;) m = g[n] + m, V(z, p, m, a, y ? 1 : (h - n) / h, l, u, A - 1);
									m = "";
								case "forward":
									for (n = 0; n < h; n++) m += g[n], V(z, p, m, a, y ? (n + 1) / h : 1, l, u, A - 1);
									break;
								case "full":
									for (n = 0; n < h; n++) {
										const w = (y ? n + 1 : h - n) / h;
										for (let x = h; x > n; x--) m = g.substring(n, x), V(z, p, m, a, w, l, u, A - 1)
									}
									break;
								default:
									if (h = V(z, p, g, a, 1, l, u, A - 1), t && 1 < k && h >= u)
										for (h = p._ctx[g] || (p._ctx[g] = B()), g = this.i[g] || (this.i[g] = ia(A - (u || 0))), l = r - t, m = r + t + 1, 0 > l && (l = 0), m > k && (m = k); l < m; l++) l !== r && V(g, h, e[l], a, 0, A - (l < r ? r - l : l - r), u, A - 1)
							}
						}
					}
					this.c[f] = 1;
					this.B = !1
				}
				return this
			};
			v.prototype.A = function (a, b, c) {
				if (E(b))
					for (let l = 0, m = b.length; l < m; l++) {
						if (l ===
							m - 1) return this.A(a, b[l], c);
						this.A(a, b[l])
					} else {
					const l = this.a.index,
						m = this.a.keys;
					var d = this.a.tag,
						e = this.a.id;
					let n;
					let p;
					for (var f = 0; f < e.length; f++) n = (n || b)[e[f]];
					if (d) {
						for (e = 0; e < d.length; e++) {
							var g = d[e];
							var h = g.split(":");
							for (f = 0; f < h.length; f++) p = (p || b)[h[f]];
							p = "@" + p
						}
						h = this.G[g];
						h = h[p] || (h[p] = [])
					}
					if ("remove" === a) {
						delete this.h[n];
						for (let k = 0, u = m.length; k < u; k++) {
							if (k === u - 1) return l[m[k]].remove(n, c), this;
							l[m[k]].remove(n)
						}
					}
					e = this.a.field;
					h && (h[h.length] = b);
					this.h[n] = b;
					for (let k = 0, u = e.length; k <
						u; k++) {
						d = e[k];
						let t;
						for (g = 0; g < d.length; g++) t = (t || b)[d[g]];
						d = l[m[k]];
						g = "add" === a ? d.add : d.update;
						k === u - 1 ? g.call(d, n, t, c) : g.call(d, n, t)
					}
				}
				return this
			};
			v.prototype.update = function (a, b, c) {
				if (this.a && J(a)) return this.A("update", a, b);
				this.c["@" + a] && M(b) && (this.remove(a), this.add(a, b, c, !0));
				return this
			};
			v.prototype.remove = function (a, b, c) {
				if (this.a && J(a)) return this.A("remove", a, b);
				var d = "@" + a;
				if (this.c[d]) {
					if (this.g) return this.m[this.c[d]].postMessage({
						remove: !0,
						id: a
					}), delete this.c[d], b && b(), this;
					if (!c) {
						if (this.async &&
							"function" !== typeof importScripts) {
							let e = this;
							d = new Promise(function (f) {
								setTimeout(function () {
									e.remove(a, null, !0);
									e = null;
									f()
								})
							});
							if (b) d.then(b);
							else return d;
							return this
						}
						if (b) return this.remove(a, null, !0), b(), this
					}
					for (b = 0; b < this.b - (this.threshold || 0); b++) ba(this.j[b], a);
					this.depth && ba(this.i, a);
					delete this.c[d];
					this.B = !1
				}
				return this
			};
			let L;
			v.prototype.search = function (a, b, c, d) {
				if (J(b)) {
					if (E(b))
						for (var e = 0; e < b.length; e++) b[e].query = a;
					else b.query = a;
					a = b;
					b = 1E3
				} else b && O(b) ? (c = b, b = 1E3) : b || 0 === b || (b = 1E3);
				let f = [],
					g = a;
				let h, l, m;
				if (J(a) && !E(a)) {
					c || (c = a.callback) && (g.callback = null);
					l = a.sort;
					h = a.page;
					b = a.limit;
					var n = a.threshold;
					m = a.suggest;
					a = a.query
				}
				if (this.a) {
					n = this.a.index;
					const y = g.where;
					var p = g.bool || "or",
						k = g.field;
					let r = p;
					let w, x;
					if (k) E(k) || (k = [k]);
					else if (E(g)) {
						var u = g;
						k = [];
						r = [];
						for (var t = 0; t < g.length; t++) d = g[t], e = d.bool || p, k[t] = d.field, r[t] = e, "not" === e ? w = !0 : "and" === e && (x = !0)
					} else k = this.a.keys;
					p = k.length;
					for (t = 0; t < p; t++) u && (g = u[t]), h && !M(g) && (g.page = null, g.limit = 0), f[t] = n[k[t]].search(g, 0);
					if (this.g) {
						this.F =
							c;
						this.u = 0;
						this.o = [];
						for (n = 0; n < this.g; n++) this.m[n].postMessage({
							search: !0,
							limit: b,
							content: g
						});
						return
					}
					if (c) return c(P.call(this, a, r, f, l, b, m, y, h, x, w));
					if (this.async) {
						const G = this;
						return new Promise(function (C) {
							Promise.all(f).then(function (D) {
								C(P.call(G, a, r, D, l, b, m, y, h, x, w))
							})
						})
					}
					return P.call(this, a, r, f, l, b, m, y, h, x, w)
				}
				n || (n = this.threshold || 0);
				if (!d) {
					if (this.async && "function" !== typeof importScripts) {
						let y = this;
						n = new Promise(function (r) {
							setTimeout(function () {
								r(y.search(g, b, null, !0));
								y = null
							})
						});
						if (c) n.then(c);
						else return n;
						return this
					}
					if (c) return c(this.search(g, b, null, !0)), this
				}
				if (!a || !M(a)) return f;
				g = a;
				if (this.cache)
					if (this.B) {
						if (c = this.l.get(a)) return c
					} else this.l.clear(), this.B = !0;
				g = this.encode(g);
				if (!g.length) return f;
				c = this.f;
				c = O(c) ? c(g) : g.split(this.split);
				this.filter && (c = W(c, this.filter));
				u = c.length;
				d = !0;
				e = [];
				const A = B();
				let z = 0;
				1 < u && (this.depth && "strict" === this.f ? p = !0 : c.sort(qa));
				if (!p || (t = this.i)) {
					const y = this.b;
					for (; z < u; z++) {
						let r = c[z];
						if (r) {
							if (p) {
								if (!k)
									if (t[r]) k = r, A[r] = 1;
									else if (!m) return f;
								if (m && z === u - 1 && !e.length) p = !1, r = k || r, A[r] = 0;
								else if (!k) continue
							}
							if (!A[r]) {
								const w = [];
								let x = !1,
									G = 0;
								const C = p ? t[k] : this.j;
								if (C) {
									let D;
									for (let N = 0; N < y - n; N++)
										if (D = C[N] && C[N][r]) w[G++] = D, x = !0
								}
								if (x) k = r, e[e.length] = 1 < G ? w.concat.apply([], w) : w[0];
								else if (!m) {
									d = !1;
									break
								}
								A[r] = 1
							}
						}
					}
				} else d = !1;
				d && (f = ha(e, b, h, m));
				this.cache && this.l.set(a, f);
				return f
			};
			v.prototype.find = function (a, b) {
				return this.where(a, b, 1)[0] || null
			};
			v.prototype.where = function (a, b, c, d) {
				const e = this.h,
					f = [];
				let g = 0;
				let h;
				var l;
				let m;
				if (J(a)) {
					c || (c =
						b);
					var n = Object.keys(a);
					var p = n.length;
					h = !1;
					if (1 === p && "id" === n[0]) return [e[a.id]];
					if ((l = this.I) && !d)
						for (var k = 0; k < l.length; k++) {
							var u = l[k],
								t = a[u];
							if (!H(t)) {
								m = this.G[u]["@" + t];
								if (0 === --p) return m;
								n.splice(n.indexOf(u), 1);
								delete a[u];
								break
							}
						}
					l = Array(p);
					for (k = 0; k < p; k++) l[k] = n[k].split(":")
				} else {
					if (O(a)) {
						b = d || Object.keys(e);
						c = b.length;
						for (n = 0; n < c; n++) p = e[b[n]], a(p) && (f[g++] = p);
						return f
					}
					if (H(b)) return [e[a]];
					if ("id" === a) return [e[b]];
					n = [a];
					p = 1;
					l = [a.split(":")];
					h = !0
				}
				d = m || d || Object.keys(e);
				k = d.length;
				for (u =
					0; u < k; u++) {
					t = m ? d[u] : e[d[u]];
					let A = !0;
					for (let z = 0; z < p; z++) {
						h || (b = a[n[z]]);
						const y = l[z],
							r = y.length;
						let w = t;
						if (1 < r)
							for (let x = 0; x < r; x++) w = w[y[x]];
						else w = w[y[0]];
						if (w !== b) {
							A = !1;
							break
						}
					}
					if (A && (f[g++] = t, c && g === c)) break
				}
				return f
			};
			v.prototype.info = function () {
				if (this.g)
					for (let a = 0; a < this.g; a++) this.m[a].postMessage({
						info: !0,
						id: this.id
					});
				else return {
					id: this.id,
					items: this.length,
					cache: this.cache && this.cache.s ? this.cache.s.length : !1,
					matcher: aa.length + (this.v ? this.v.length : 0),
					worker: this.g,
					threshold: this.threshold,
					depth: this.depth,
					resolution: this.b,
					contextual: this.depth && "strict" === this.f
				}
			};
			v.prototype.clear = function () {
				return this.destroy().init()
			};
			v.prototype.destroy = function () {
				this.cache && (this.l.clear(), this.l = null);
				this.j = this.i = this.c = null;
				if (this.a) {
					const a = this.a.keys;
					for (let b = 0; b < a.length; b++) this.a.index[a[b]].destroy();
					this.a = this.h = null
				}
				return this
			};
			v.prototype.export = function () {
				let a;
				if (this.a) {
					const b = this.a.keys;
					a = Array(b.length + 1);
					let c = 0;
					for (; c < b.length; c++) {
						const d = this.a.index[b[c]];
						a[c] = [d.j, d.i, Object.keys(d.c)]
					}
					a[c] = this.h
				} else a = [this.j, this.i, Object.keys(this.c)];
				return JSON.stringify(a)
			};
			v.prototype.import = function (a) {
				a = JSON.parse(a);
				const b = B();
				if (this.a) {
					var c = this.a.keys,
						d = c.length,
						e = a[0][2];
					for (var f = 0; f < e.length; f++) b[e[f]] = 1;
					for (e = 0; e < d; e++) f = this.a.index[c[e]], f.j = a[e][0], f.i = a[e][1], f.c = b, f.h = a[d];
					this.h = a[d]
				} else {
					c = a[2];
					for (d = 0; d < c.length; d++) b[c[d]] = 1;
					this.j = a[0];
					this.i = a[1];
					this.c = b
				}
			};
			const U = {
				icase: function (a) {
					return a.toLowerCase()
				},
				simple: function () {
					const a = [q("[\u00e0\u00e1\u00e2\u00e3\u00e4\u00e5]"),
						"a", q("[\u00e8\u00e9\u00ea\u00eb]"), "e", q("[\u00ec\u00ed\u00ee\u00ef]"), "i", q("[\u00f2\u00f3\u00f4\u00f5\u00f6\u0151]"), "o", q("[\u00f9\u00fa\u00fb\u00fc\u0171]"), "u", q("[\u00fd\u0177\u00ff]"), "y", q("\u00f1"), "n", q("[\u00e7c]"), "k", q("\u00df"), "s", q(" & "), " and ", q("[-/]"), " ", q("[^a-z0-9 ]"), "", q("\\s+"), " "
					];
					return function (b) {
						b = Q(b.toLowerCase(), a);
						return " " === b ? "" : b
					}
				}(),
				advanced: function () {
					const a = [q("ae"), "a", q("ai"), "ei", q("ay"), "ei", q("ey"), "ei", q("oe"), "o", q("ue"), "u", q("ie"), "i", q("sz"),
						"s", q("zs"), "s", q("sh"), "s", q("ck"), "k", q("cc"), "k", q("th"), "t", q("dt"), "t", q("ph"), "f", q("pf"), "f", q("ou"), "o", q("uo"), "u"
					];
					return function (b, c) {
						if (!b) return b;
						b = this.simple(b);
						2 < b.length && (b = Q(b, a));
						c || 1 < b.length && (b = ca(b));
						return b
					}
				}(),
				extra: function () {
					const a = [q("p"), "b", q("z"), "s", q("[cgq]"), "k", q("n"), "m", q("d"), "t", q("[vw]"), "f", q("[aeiouy]"), ""];
					return function (b) {
						if (!b) return b;
						b = this.advanced(b, !0);
						if (1 < b.length) {
							b = b.split(" ");
							for (let c = 0; c < b.length; c++) {
								const d = b[c];
								1 < d.length && (b[c] =
									d[0] + Q(d.substring(1), a))
							}
							b = b.join(" ");
							b = ca(b)
						}
						return b
					}
				}(),
				balance: function () {
					const a = [q("[-/]"), " ", q("[^a-z0-9 ]"), "", q("\\s+"), " "];
					return function (b) {
						return ca(Q(b.toLowerCase(), a))
					}
				}()
			},
				ua = function () {
					function a(b) {
						this.clear();
						this.H = !0 !== b && b
					}
					a.prototype.clear = function () {
						this.cache = B();
						this.count = B();
						this.index = B();
						this.s = []
					};
					a.prototype.set = function (b, c) {
						if (this.H && H(this.cache[b])) {
							let d = this.s.length;
							if (d === this.H) {
								d--;
								const e = this.s[d];
								delete this.cache[e];
								delete this.count[e];
								delete this.index[e]
							}
							this.index[b] =
								d;
							this.s[d] = b;
							this.count[b] = -1;
							this.cache[b] = c;
							this.get(b)
						} else this.cache[b] = c
					};
					a.prototype.get = function (b) {
						const c = this.cache[b];
						if (this.H && c) {
							var d = ++this.count[b];
							const f = this.index;
							let g = f[b];
							if (0 < g) {
								const h = this.s;
								for (var e = g; this.count[h[--g]] <= d && -1 !== g;);
								g++;
								if (g !== e) {
									for (d = e; d > g; d--) e = h[d - 1], h[d] = e, f[e] = d;
									h[g] = b;
									f[b] = g
								}
							}
						}
						return c
					};
					return a
				}();
			return v
		}(function () {
			const I = {},
				R = "undefined" !== typeof Blob && "undefined" !== typeof URL && URL.createObjectURL;
			return function (v, K, S, W, P) {
				S = R ? URL.createObjectURL(new Blob(["(" +
					S.toString() + ")()"
				], {
					type: "text/javascript"
				})) : v + ".min.js";
				v += "-" + K;
				I[v] || (I[v] = []);
				I[v][P] = new Worker(S);
				I[v][P].onmessage = W;
				return I[v][P]
			}
		}()), this);
	</script>

</body>

</html>